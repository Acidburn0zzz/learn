#!/usr/bin/env bash
#chilicuil <chilicuil@gmail.com> 2011

#rm_, is a wrapper for the existing rm command compatible with nautilus and other
#trash management tools

# -f files are removed and NOT archived
# -l list archived files
# -c remove permanently archived files
# -u recover archived files

#Taken in most part from 'Wicked Cool Shell Scripts: 101 Scripts for Linux, Mac
#OS X, and Unix Systems'

#TODO 03-01-2011 00:17 => Implement custom recover & clean procedures
#TODO 08-08-2011 05:23 => recover, clean & list functions share lots of code

trash_dir="$HOME/.local/share/Trash"
RM="/bin/rm"

if [ $# -eq 0 ] ; then # let 'rm' ouptut the usage error
    exec $RM  #our shell is replaced by /bin/rm, keeping original status unmodified
fi

archive ()
{
    #TODO 08-08-2011 01:19 => report nautilus bug: recovering foo/1, foo/bar/1, foo/bar/rar/1
    #                         gives foo/1 foo/bar/1.2 foo/bar/rar/1.3
    for file
    do
        if [ -e "$file" ] ; then
            archive="$trash_dir/files/$(basename "$file")"
            trashinfo="$trash_dir/info/$(basename "$file").trashinfo"

            #man bash: declare -i gives to $num the integer attribute
            #declare -i num=2
            num=2

            while [ -e "$archive" ]; do
                archive="$trash_dir/files/$(basename "$file")".$num
                trashinfo="$trash_dir/info/$(basename "$file").$num.trashinfo"
                #num+=1
                num=$(($num+ 1))
            done

            #put $file & $trashinfo vars between "" to capture spaces
            echo "[Trash Info]"                         >  "$trashinfo"
            echo "Path=$(realpath "$file")"             >> "$trashinfo"
            echo "DeletionDate=$(date +%Y-%m-%dT%T)"    >> "$trashinfo"

            mv "$file" "$archive"
        fi
    done
}

list ()
{
    #TODO 03-01-2011 00:08 => recive pattern, save to a dictionary?
    files_in_trash=($trash_dir/info/*.trashinfo)

    if [ ! -e ${files_in_trash[0]} ] ; then
        echo "$(basename $0): Nothing to list" >&2 ; exit 1
    fi

    for data_in_trashinfo in $(find $trash_dir/info -name "*.trashinfo" | sort | xargs grep -A 1 -Hri path \
                             | sed -e 's:^:|:g' -e 's:\.trashinfo.*=:|:g'\
                             | tr -d '\n'| sed -e 's:--:\n:g'); do

        datetime=$(echo $data_in_trashinfo | cut -d\| -f5)
        general_date=$(echo $datetime | cut -dT -f1)
        detail_date=$(echo $datetime | cut -dT -f2)
        name=$(echo $data_in_trashinfo | cut -d\| -f3)
        real_file=$(echo $data_in_trashinfo | cut -d\| -f2 | sed -e 's:\/info\/:\/files\/:g')
        size=$(du -sh $real_file | awk '{print $1}')
    
        if [ -d $real_file ] ; then
            if [ $verboselist -gt 1 ]; then
                some="$(ls $real_file | wc -l | sed 's/[^[:digit:]]//g')"
                echo -e "$some\t$size\t$general_date $detail_date $name/"
                if [ $verboselist -gt 2 ]; then
                    find $real_file | sed -e "s:$trash_dir/files::g" | sed -e 's:^:\t\t|_ ..:g'
                fi
            else
                echo $name/
            fi
        else
            if [ $verboselist -gt 1 ]; then
                some=1
                echo -e "$some\t$size\t$general_date $detail_date $name"
            else
                echo $name
            fi
        fi
    done
}

recover ()
{
    #TODO 08-08-2011 04:03 => parent dir doesn't exist, maybe this script could
    #                         create it?

    #TODO 08-08-2011 04:35 => the files to be restored already exist in the fs,
    #                         overwrite?

    #TODO 08-08-2011 05:39 => "*" matchs nothing
    for pattern
    do
        for data_in_trashinfo in $(find $trash_dir/info -name "*.trashinfo" | sort | xargs grep -A 1 -Hri -E $pattern \
                             | sed -e 's:^:|:g' -e 's:\.trashinfo.*=:|:g'\
                             | tr -d '\n'| sed -e 's:--:\n:g'); do

        datetime=$(echo $data_in_trashinfo | cut -d\| -f5)
        general_date=$(echo $datetime | cut -dT -f1)
        detail_date=$(echo $datetime | cut -dT -f2)
        name=$(echo $data_in_trashinfo | cut -d\| -f3)
        real_file=$(echo $data_in_trashinfo | cut -d\| -f2 | sed -e 's:\/info\/:\/files\/:g')
        size=$(du -sh $real_file | awk '{print $1}')
    
        if [ -d $real_file ] ; then
            if [ $verboselist -gt 1 ]; then
                some="$(ls $real_file | wc -l | sed 's/[^[:digit:]]//g')"
                echo -e "$some\t$size\t$general_date $detail_date $name/"
                if [ $verboselist -gt 2 ]; then
                    find $real_file | sed -e "s:$trash_dir/files::g" | sed -e 's:^:\t\t|_ ..:g'
                fi
            else
                echo $name/
            fi
        else
            if [ $verboselist -gt 1 ]; then
                some=1
                echo -e "$some\t$size\t$general_date $detail_date $name"
            else
                echo $name
            fi
        fi
    done
done

        #if [ -e "$file" ] ; then
            #archive="$trash_dir/files/$(basename "$file")"
            #trashinfo="$trash_dir/info/$(basename "$file").trashinfo"

            ##man bash: declare -i gives to $num the integer attribute
            ##declare -i num=2
            #num=2

            #while [ -e "$archive" ]; do
                #archive="$trash_dir/files/$(basename "$file")".$num
                #trashinfo="$trash_dir/info/$(basename "$file").$num.trashinfo"
                ##num+=1
                #num=$(($num+ 1))
            #done

            ##put $file & $trashinfo vars between "" to capture spaces
            #echo "[Trash Info]"                         >  "$trashinfo"
            #echo "Path=$(realpath "$file")"             >> "$trashinfo"
            #echo "DeletionDate=$(date +%Y-%m-%dT%T)"    >> "$trashinfo"

            #mv "$file" "$archive"
        #fi
    #done
        
    # list pattern
    # for data_in_trashinfo in $data
    # do
    #    real_file=$(echo data_in_trashinfo | cut ...)
    #    name=$(echo data_in_trashinfo | cut ...)
    #    $MV $real_file $name
    #    $RM -rf $real_file.info
    # done

    #list
    #echo -n "Recover all items from trash? (Y/n) "
    #answer=y
    #read answer
    #if [ ! $answer == "y" ]; then
        #echo "Nothing done" && exit 0
    #else
         # for data_in_trashinfo in $data
         # do
         #    real_file=$(echo data_in_trashinfo | cut ...)
         #    name=$(echo data_in_trashinfo | cut ...)
         #    $MV $real_file $name
         #    $RM -rf $real_file.info
         # done
    #fi

    echo recover
    exit
}

clean ()
{
    # list pattern
    # for data_in_trashinfo in $data
    # do
    #    real_file=$(echo data_in_trashinfo | cut ...)
    #    $RM -rf real_file
    #    $RM -rf real_file.info
    # done

    list
    echo -n "Empty all items from trash? (Y/n) "
    answer=y
    read answer
    if [ ! $answer == "y" ]; then
        echo "Nothing done" && exit 0
    else
        $RM -rf $trash_dir/files/*
        $RM -rf $trash_dir/info/*
    fi

}

verboselist=0
while getopts ":flurc" options
do
    case $options in
        f) exec $RM -r "$@"                     ;;  # exec lets us exit this script directly.
        l) verboselist=$(($verboselist+1))      ;;  # list verbose level 1-3
        u) shift $(($OPTIND - 1)); recover "$@" ;;  # remove the -u
        c) clean                                ;;
        *) exec $RM "$@"                        ;;  # other flags are for 'rm', not for us
    esac
done
shift $(($OPTIND - 1))

if [ $verboselist -gt 0 ]; then
    list
fi

# Make sure that the $trash_dir exists
if [ ! -d $trash_dir ] ; then
    if [ ! -w $HOME ] ; then
        echo "$0 failed: can't create $trash_dir in $HOME" >&2
        exit 1
    fi
    mkdir -p $trash_dir/{expunged,files,info}
    chmod -R 700 $trash_dir
fi

archive "$@"

exit 0
